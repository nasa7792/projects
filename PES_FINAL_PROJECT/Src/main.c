/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 *
 * PES FINAL PROJECT :interfacing mpu 6050 with STM32 nucleo board
 *
 * functionalities : 1- Converting mpu pitch and roll values to led pwm values
 * 				   : 2- Using mpu interrupt pin to trigger interupts and display blinking pattern on jump
 * 
 * Refrences- setting up interrupts on mpu 6050 https://www.eluke.nl/2016/08/11/how-to-enable-motion-detection-interrupt-on-mpu6050/
 * 			- setting up pwm https://github.com/alexander-g-dean/ESF/tree/master/ST/Code/ch7
 *
 ******************************************************************************
 */

#include <stdio.h>
#include <stm32f091xc.h>
#include "utilities.h"
#include "mpu6050_driver.h"
#include "delay.h"
#include "timer_pwm.h"
#include "LED_module.h"
#include "I2C_bitbanging_approach.h"
#include "tests.h"

volatile int mpu_jump_detect_flag = 0; // a volatile flag to check if a jump was deteced
volatile int jump_count = 0;		   // a counter to keep count of the number of jumps

void EXTI0_1_IRQHandler(void)
{
	if (EXTI->PR & EXTI_PR_PR0)
	{ // check if interrupt happened due to pa0

		EXTI->PR |= EXTI_PR_PR0; // clear interrupt flag

		// read mpu status register to clear interrupt
		uint8_t motion_stat;
		motion_stat = I2C_READ_REGISTER(MPU6050_REG_MOT_DETECT_STATUS);

		// if motion_stat happened in +z direction a jump happened !
		if ((motion_stat >> MPU_POS_Z_DIRECTION_MASK) & 1)
		{
			mpu_jump_detect_flag = 1; // make jump flag high
			jump_count++;			  // Increment jump count
		}
	}
}

int main(void)
{
	/*
	 * Clocks: Processor = 48 MHz. AHB = 48 MHz. APB = 24 MHz.
	 */

	I2C_bitbanging_init(); // Initialize bit banged i2c
	MPU_INIT();			   // Initialize mpu
	delay_init();		   // Initialize systick
	test_run_suite();	   // run the test suite

	configure_display_LEDS();  // configure our pwm leds
	setup_pwm_channels();	   // set pwm channels
	configure_Mcu_MPU_pin();   // configure Pa0 to be connected to mpu
	configure_exti_interupt(); // configure interrupt on pa0

	// declare variables and consts related to gyro and accel data fetching and calculation
	const float delta_t = 0.01;
	int16_t ACCEL_X_RAW;
	int16_t ACCEL_Y_RAW;
	int16_t ACCEL_Z_RAW;

	int16_t GYRO_X_RAW;
	int16_t GYRO_Y_RAW;
	int16_t GYRO_Z_RAW;

	float fused_pitch = 0.0, fused_roll = 0.0;
	float accel_pitch = 0.0, accel_roll = 0.0;

	// main loop
	while (1)
	{
		// if jump flag is high execute the jump sequence jump_count time
		if (mpu_jump_detect_flag == 1)
		{
			execute_jump_sequence(jump_count);
			mpu_jump_detect_flag = 0;
		}
		get_ACCEL_VALUES(&ACCEL_X_RAW, &ACCEL_Y_RAW, &ACCEL_Z_RAW);
		get_GYRO_VALUES(&GYRO_X_RAW, &GYRO_Y_RAW, &GYRO_Z_RAW);
		calculate_pitch_roll_values(&accel_pitch, &accel_roll, ACCEL_X_RAW, ACCEL_Y_RAW, ACCEL_Z_RAW);

		// fuse values from both accel and gyro sensor with complimentary filter
		fused_pitch = FILTER_COEF * (fused_pitch + (GYRO_Y_RAW / LSB_SENSITIVITY_GYRO) * delta_t) + (1 - FILTER_COEF) * accel_pitch;
		fused_roll = FILTER_COEF * (fused_roll + (GYRO_X_RAW / LSB_SENSITIVITY_GYRO) * delta_t) + (1 - FILTER_COEF) * accel_roll;
		//   	printf("fused_roll: %f unfused %f \n\r", fused_roll,accel_roll);
		//		printf("fused_pitch: %f \n\r", fused_pitch);
		update_led_brightness_values(fused_roll, fused_pitch); // update pwm values after fetching mpu values
		delay(1);
	}
}
